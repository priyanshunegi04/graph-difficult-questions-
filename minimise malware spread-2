class Solution {
public:
    //tc--->O(n^3)
    //sc-->O(n);
    void dfs(int node, set<int>&vis, vector<vector<int>>& graph, int &cnt ){
   //if it is visited reurn;
   if(vis.count(node)){
        return;
    }    
   cnt++;     
   vis.insert(node);     
        
   for(int nbr = 0; nbr<graph.size(); nbr++){
       if(graph[node][nbr] == 1 && node!=nbr){
           dfs(nbr, vis, graph, cnt);
       }
   }     
    return ;    
    }
      
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        
    int n = graph.size();    
    int minCnt = n + 1;  
        
    int nodeRemoved = -1;    
        sort(initial.begin(), initial.end());
        for(auto nodeToremove: initial){
            set<int>vis;
            vis.insert(nodeToremove);
            //it will calculate node infected after removal of initial node
            int cnt = 0;
            for(auto infected: initial){
                dfs(infected, vis, graph, cnt);
            }      
            if(cnt < minCnt){
                minCnt = cnt;
                nodeRemoved = nodeToremove;
            }    
        } 
    return nodeRemoved;    
    }
};
